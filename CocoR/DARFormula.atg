$namespace=ElaroSolutions::DARFormula

COMPILER DARFormula

CHARACTERS
  letter     = 'a'..'z'+'A'..'Z'.
  digit      = '0'..'9'.
  hexdigit   = digit + "ABCDEF".
  octdigit   = '0'..'7'.
  bindigit   = "01".
  eol        = '\n'.

TOKENS
  variable   = (letter { letter | digit | '_' }).
  data       = "data".
  sin        = "sin".
  cos        = "cos".
  tan        = "tan".
  asin       = "asin".
  acos       = "acos".
  atan       = "atan".
  sinh       = "sinh".
  cosh       = "cosh".
  tanh       = "tanh".
  log        = "log".
  ln         = "ln".
  sqrt       = "sqrt".
  ceil       = "ceil".
  floor      ="floor".
  abs        ="abs".
  sum        = "sum".
  mult       = "mult".
  number     = digit {digit} ['.' digit {digit}]
             | "0x" hexdigit {hexdigit} ['.' hexdigit {hexdigit}]
             | "0o" octdigit {octdigit} ['.' octdigit {octdigit}]
             | "0b" bindigit {bindigit} ['.' bindigit {bindigit}].
  comp       = '=' | "!=" | '>' | '<'.
  plus       = '+'.
  minus      = '-'.
  muldivmod  = '*' | '/' | '%'.
  exp        = '^'.
  comma      = ','.
  leftparen  = '('.
  rightparen = ')'.
  leftbrack  = '['.
  rightbrack = ']'.

  COMMENTS FROM '#' TO eol

  IGNORE ' ' + '\t'

  PRODUCTIONS

  DARFormula             (. Node *e=nullptr;.)
  = 
    Formula <&e>
  .

  Formula <Node *e>     (. BinaryFunctions op = Undefined;
                           Node *e2=nullptr;.)
  =
    Expression <&e>
    {comp               (. if(t->val=="=")
                           {op = Equals;}
                           else if(t->val=="!=")
                           {op = Unequals;}
                           else if(t->val=="<")
                           {op = Lesser;}
                           else if(t->val==">")
                           {op = Greater;}
                        .)
    Expression <&e2>    (. e = BinaryNode.BinaryNodeConstructor(e,e2,op); .)
    }  
  .
  
  Expression <Node *e> (.BinaryFunctions op = Undefined;
                         Node *e2=nullptr;.)
  = 
    Term <&e>
    {(
      plus             (. op = Plus; .)
      |minus           (. op = Minus .)
      )         
      Term <&e2>       (. e = BinaryNode.BinaryNodeConstructor(e,e2,op); .)
    }
  . 
  
  Term <Node *e>      (.BinaryFunctions op = Undefined; 
                        Node *e2=nullptr;.)
  = 
    Factor <&e>
    {muldivmod        (.if(t->val=="*")
                           {op = Times;}
                        else if(t->val=="/")
                           {op = Divide;}
                        else if(t->val=="%")
                           {op = Modulo;}
                      .)       
    Factor <&e2>      (. e = BinaryNode.BinaryNodeConstructor(e,e2,op); .)
    }
  .
  
  Factor <Node *e>    
  = 
    PossiblyNegatedOperand <&e>
    {exp PossiblyNegatedOperand <&e2> (. e = BinaryNode.BinaryNodeConstructor(e,e2, Exponent); .)
    }
  . 
  
  PossiblyNegatedOperand <Node *e>    (. bool isNegated = false; .)
  =
    [minus                            (. isNegated = true; .)
    ] Operand <&e>                    (. if(isNegated){e = UnaryNode.UnaryNodeConstructor(e,Negate); }.)
  .


  Operand <Node *e>
  = 
    Quantity <&e>
    | (. UnaryFunctions op=Undefined;.) 
         Func <&op> leftparen Formula <&e> rightparen (. e = UnaryNode.UnaryNodeConstructor(e,op);.)
    | (. TernaryFunctions op=Undefined;
         std::string countingVariable; 
         Node *lim;.) 
         Func3 <&op> leftparen variable (. countingVariable=t->val; .) comma Formula <&lim> comma Formula <&e> rightparen  (. e = TernaryNode.TernaryNodeConstructor(countingVariable,lim,e,op); .)
    | leftparen Formula <&e> rightparen
  .
  
  Func <UnaryFunctions op>                        
  =
    (sin|cos|tan|asin|acos|atan|sinh|cosh|tanh|log|ln|sqrt|ceil|floor|abs)
                               (. op = t->kind; .)
  .
  
  Func3 <TernaryFunctions op>    
  = 
    (sum| mult)                (. op = t->kind;.)  
  .

  Quantity <SimpleNode *e> 
  = 
    Data <&e>
    | variable                 (. e = new VariableNode(t->val).)   
    | number                   (. e = new ValueNode((double)std::atof(t-val));.) 
  .

  Data <DataNode *e>           (. vector<Node*> indexes = new vector<Node*>();
                                  std::string fieldName = "";
                                  Node *e2=nullptr; .)
  =
    data leftbrack Formula <&e> rightbrack (. indexes.push_back(e); .)
    {
      leftbrack Formula <&e2> rightbrack   (. indexes.push_back(e2); .)
    }
    [leftbrack variable (. fieldName = t->val; .) rightbrack
    ]           
                               (. e = new DataNode(indexes, fieldName);.)
  .

END DARFormula.